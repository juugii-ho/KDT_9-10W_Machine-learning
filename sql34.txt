

 
📖SQLD. 제 34 회 기출 문제


문제 1. 도메인의 특징으로 알맞지 않은 것은? 정답확인🌼




1) 엔터티 내에서 속성에 대한 데이터 타입과 크기를 지정한다.2) 엔터티 내에서 속성에 대한 NOT NULL 을 지정한다.3) 엔터티 내에서 속성에 대한 Check 조건을 지정한다.4) 테이블의 속성 간 FK 제약 조건을 지정한다.




 

문제 2. 아래의 그림에 대한 식별자의 분류를 알맞게 짝지은 것은? 정답확인🌼





1) 주식별자 - 본질식별자 - 보조식별자 - 복합식별자2) 본질식별자 - 주식별자 - 보조식별자 - 복합식별자3) 주식별자 - 보조식별자 - 본질식별자 - 복합식별자4) 주식별자 - 보조식별자 - 인조식별자 - 복합식별자




 

문제 3. 다음 중 주식별자를 도출하기 위한 기준으로 적절하지 않은 것은? 정답확인🌼




1) 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.2) 명칭, 내역 등과 같이 이름으로 기술되는 것들은 가능하면 주식별자로 지정하지 않는다.3) 복합으로 주식별자로 구성할 경우 너무 많은 속성이 포함되지 않도록 한다4) 지정된 주식별자의 값은 변경될 수도 있다.





문제 4. 다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은? 정답확인🌼
 

<시나리오>
S 병원은 여러 명의 환자가 존재하고 각 환자에 대한 이름, 주소 등을 관리해야 한다
(단, 업무범위와 데이터의 특성은 상기 시나리오에 기술되어 있는 사항만을 근거하여 판단해야 함)





1) 병원2) 환자3) 이름4) 주소




 

문제 5. 주식별자의 특징으로 가장 적절하지 않은 것은? 정답확인🌼




1) 유일성 : 주식별자에 의해 엔터티내에서 모든 인스턴스들을 유일하게 구분함2) 최소성 : 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 함3) 불변성 : 주식별자가 한 번 특정 엔터티에 지정되면 그 식별자의 값은 변하지 않아야 함4) 존재성 : 주식별자가 지정되면 데이터 값이 존재하지 않을 수 있음 (NULL 허용)




 

문제 6. 다음 중 컬럼에 대한 반정규화 기법으로 가장 적절하지 않은것은? 정답확인🌼




1) 중복칼럼을 추가 - 조인감소를 위해 여러 테이블에 동일한 칼럼을 갖도록 한다.2) 파생칼럼을 추가한다 - 조회 성능을 우수하게 하기 위해 미리 계산된 칼럼을 갖도록 한다.3) 이력테이블에 기능 칼럼을 추가한다 - 최신값을 처리하는 이력의 특성을 고려하여 기능성 칼럼을 추가한다.4) FK에 대한 속성을 추가한다 - FK관계 에 해당하는 속성을 추가하여 조인 성능을 높인다.




 

문제 7. 아래의 ERD 에 대한 반정규화 기법으로 적절하지 않은 것은? 정답확인🌼




1) 배송 테이블에서 고객의 정보를 찾는 빈도가 높을 경우 고객과 배송 테이블의 관계를 추가하는 관계의 반정규화를 한다.2) 주문목록 테이블에서 고객이 정보를 찾는 빈도가 높을 경우 고객과 주문 테이블의 비식별자 관계를 식별자 관계로 한다.3) 주문 테이블에서 항상 고객명을 같이 조회하는 경우 고객 테이블의 고객명을 주문 테이블에 넣컬럼의 반정규화를 한다.4) 주문과 주문목록, 배송 테이블의 모든 컬럼을 고객 (최상위 테이블) 테이블에 모두 넣는 반정규화를 한다.




 

문제 8. 아래의 ERD를 참고하여 테이블에 대한 관계를 설명하는 것으로 가장 적절한 것은? 정답확인🌼




1) 주문은 여러 개의 제품을 가질 수 있고, 제품은 하나의 주문에만 속할 수 있다.2) 제품은 여러 개의 주문에 속할 수 있고, 주문은 하나의 제품만 가질 수 있다.3) 주문 1개는 여러개의 제품을 가질 수 있으며, 제품 1개는 여러개의 주문에 속할 수 있다.4) 주문은 제품을 하나도 안 가질 수 있다.




 

문제 9. 아래의 테이블에 대한 이상 현상에 대한 설명 중 가장 적절하지 않은 것은? 정답확인🌼
<SQLD_34_09>



1) 삽입이상 : 상품을 주문하지 않은 고객의 정보를 삽입할 수 없다.2) 갱신이상 : 스마트폰의 정보를 업데이트 할 경우 유비의 스마트폰만 업데이트 하면 된다.3) 갱신이상 : 노트북의 가격을 업데이트 할 경우 관우의 노트북만 업데이트 하면 된다.4) 삭제이상 : 장비의 고객정보가 삭제되면 LEN 카드 상품의 정보도 삭제된다.




 

문제 10. 속성의 특징으로 가장 올바른 것은? 정답확인🌼




1) 엔터티는 한 개의 속성만으로 구성될 수 있다.2) 엔터티를 설명하고 인스턴스의 구성요소가 된다.3) 하나의 속성에는 여러개의 속성값을 가질 수 있다.4) 속성의 특성에 따른 분류에는 PK 속성, FK 속성, 일반 속성이 있다.




 

문제 11. TRUNCATE TABLE 명령어의 특징으로 가장 적절한 것은? 정답확인🌼
 




1) 테이블 자체를 삭제하는 명령어로 DROP TABLE 과 동일한 명령어이다.2) 특정 로우를 선택하여 지울 수 없다.3) DELETE TABLE 과는 다르게 TRUNCATE TABLE의 경우 정상적인 복구가 가능하다.4) DELETE TABLE 보다 시스템 부하가 더 크다.




 

문제 12. 다음의 SCRIPT 를 수행한 후 보기의 SQL 을 수행할 때 잘못된 것은? 정답확인🌼
<SCRIPT>
CREATE TABLE SQLD_34_12 (N1 NUMBER, N2 NUMBER);
INSERT INTO SQLD_34_12 VALUES (1,10);
INSERT INTO SQLD_34_12 VALUES (2,20);
📝Memo 




1) SELECT N1 FROM SQLD_34_12 ORDER BY N2;2) SELECT*FROM SQLD_34_12 ORDER BY 2;3) SELECT N1 FROM (SELECT*FROM SQLD_34_12) ORDER BY N2;4) SELECT N1 FROM (SELECT*FROM SQLD_34_12) ORDER BY 2;




 

문제 13. PROCEDURE, TRIGGER 에 대한 설명 중 가장 잘못된 것은? 정답확인🌼
 




1) PROCEDURE, TRIGGER 모두 EXECUTE 명령어로 수행된다.2) PROCEDURE, TRIGGER 모두 CREATE 명령어로 생성한다.3) PROCEDURE 는 COMMIT, ROLLBACK 명령어를 사용할 수 있다.4) TRIGGER 는 COMMIT, ROLLBACK 명령어를 사용할 수 없다.




 

문제 14. 아래의 데이터를 바탕으로 다음의 SQL 을 수행하였을때의 설명으로 적절하지 않은 것은? 정답확인🌼
<SQL>
SELECT CONNECT_BY_ROOT LAST_NAME AS BOSS,
    MANAGER_ID,
    EMPLOYEE_ID,
    LAST_NAME,
    LEVEL,
    CONNECT_BY_ISLEAF,
    SYS_CONNECT_BY_PATH(LAST_NAME,'-') "PATH"
FROM HR.EMPLOYEES
WHERE 1=1
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID
<RESULT>
📝Memo 



1) [    ] 는 KING 이다.2) CONNECT_BY_ISLEAF 는 LEAF면 1을 아니면 0을 반환한다.3) 자식에서 부모로 가는 역방향이다.4) LEVEL은 계층의 깊이를 의미하며 KING은 최상위 계층이다.



 

문제 15. PLAYER 테이블에서 선수명과 팀명은 오름차순, 연봉은 내림차순으로 조회하는 SQL 로 바른것은? 정답확인🌼




1) SELECT 선수명, 팀명, 연봉 FROM ORDER BY 선수명 DESC, 팀명 DESC, 연봉 ASC2) SELECT 선수명, 팀명, 연봉 FROM ORDER BY 선수명 ASC, 팀명 ASC, 연봉3) SELECT 선수명, 팀명, 연봉 FROM ORDER BY 선수명 ASC, 팀명, 3 DESC4) SELECT 선수명, 팀명, 연봉 FROM ORDER BY 선수명, 팀명, DESC 연봉




 

문제 16. 아래의 SQL에 대한 실행계획에 대한 설명으로 부적절한 것은? 정답확인🌼

📝Memo 



1) 성능향상을 위해 HASH JOIN을 NESTED LOOP JOIN 으로 변경한다.2) SQL의 실행 순서는 2->3->1->0 이다.3) DEPARTMENTS 테이블이 EMPLOYEES보다 소량으로 선행으로 하는 것이 좋다.4) 조인 조건이 Non-Equal 일 경우 HASH JOIN 으로 수행되지 못하고 MERGE JOIN으로 수행된다.




 

문제 17. 테이블이 다음과 같을 때 아래의 SQL 연산결과로 알맞은 것은?정답확인🌼

<SQL>
1) SELECT SUM(COL1+COL2+COL3+COL4) FROM SQLD_34_17;

2) SELECT SUM(COL1)+SUM(COL2)+SUM(COL3)+SUM(COL4) FROM SQLD_34_17;
📝Memo 




1) 4, NULL2) NULL, 223) 4, 224) NULL, NULL




 

문제 18. 아래의 SQL에서 NULL을 반환하는 SQL은 어떤것인가? 정답확인🌼
 



1) SELECT COALESCE(NULL,'2') FROM DUAL2) SELECT NULLIF('A','A') FROM DUAL3) SELECT NVL(NULL,0) + 10 FROM DUAL4) SELECT NVL(NULL,'A') FROM DUAL



 

문제 19. 아래의 테이블에 대한 SQL중 결과가 다른 하나는 무엇인가? 정답확인🌼
<SQLD_34_19>📝Memo 



1) SELECT C1, C2, N1,N2 FROM SQLD_34_19 WHERE N1=4 START WITH N2 IS NULL CONNECT BY PRIOR N1 = N2 ;2) SELECT C1, C2, N1,N2 FROM SQLD_34_19 START WITH C2 ='B' CONNECT BY PRIOR N1 = N2 AND C2 <>'D'3) SELECT C1, C2, N1,N2 FROM SQLD_34_19 START WITH C1 ='B' CONNECT BY PRIOR N1 = N2 AND PRIOR C2 ='B'4) SELECT C1, C2, N1,N2 FROM SQLD_34_19 WHERE C1 <>'B' START WITH N1 =2 CONNECT BY PRIOR N1 = N2 AND PRIOR N1 =2;



 

문제 20. 아래의 테이블에 대해 다음의 SCRIPT를 수행한 결과로 알맞은 것은? 정답확인🌼
<SQLD_34_20>
📝Memo 
<SQL>
SELECT ID, DEPT_NM, SUM(SALARY)
FROM SQLD_34_20
GROUP BY ROLLUP(ID,DEPT_NM);

 

문제 21. SCRIPT 를 수행한 결과가 다음과 같을 때 수행한 SQL의 빈칸에 넣을 알맞은 그룹함수는?정답확인🌼
<SQL>
SELECT ID, DEPT_NM, SUM(AMT)
FROM SQLD_34_21
GORUP BY (    )
<RESULT>



1) CUBE (ID, DEPT_NM)2) ROLLUP (ID, DEPT_NM)3) GROUPING SETS (ID, DEPT_NM)4) CUBE (ID)



 

문제 22. 아래의 GROUP 함수에 대한 설명으로 가장 적절한 것은? 정답확인🌼



1) CUBE는 결합 가능한 모든 값에 대하여 다차원 집계를 생성한다.2) ROLLUP은 계층구조가 평등한 관계이므로 인수의 순서가 바뀌어도 결과는 같다.3) ROLLUP, CUBE, GROUPING SETS 은 특정 컬럼에 대한 정렬은 가능하나 계층간 정렬은 불가능하다.4) ROLLUP은 CUBE에 비해 시스템에 많은 부담을 주므로 사용에 주의해야 한다.



 

문제 23. 아래의 테이블에 대한 SQL 결과로 올바른 것은? 정답확인🌼

<SQL>
SELECT COUNT(*)
FROM SQLD_34_23
HAVING COUNT(*) > 4



1) 공집합이다 (0 Rows)2) 03) 14) 2



 

문제 24. 아래의 트랜잭션 특성에 대한 설명을 올바르게 연결한 것은? 정답확인🌼
<설명>
(ᄀ) : 트랜잭션에서 정의된 연산들은 모두 성공적으로 실행 되던지 아니면 전혀 실행되지 않은 상태로 남아 있어야 한다.
(ᄂ) : 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안된다.
(ᄃ) : 트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장된다.
(ᄅ) : 트랜잭션이 실행 되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이
있으면 안된다



1) 일관성, 원자성, 지속성, 고립성2) 원자성, 일관성, 지속성, 고립성3) 원자성, 고립성, 지속성, 일관성4) 고립성, 원자성, 일관성, 지속성



 

문제 25. 아래의 테이블에 대한 SELECT 결과 건수로 알맞은 것은? 정답확인🌼

📝Memo 
<SQL>
SELECT DISTINCT COL1
FROM SQLD_34_25_01
UNION ALL
SELECT COL1
FROM SQLD_34_25_02



1) 42) 63) 84) 10



 

문제 26. 아래와 같은 테이블이 있다. 스크립트를 수행한 후의 결과로 가장 올바른 것은?  정답확인🌼
<SQLD_34_26_01>   <SQLD_34_26_02>   <SQLD_34_26_03>   <SQLD_34_26_04>

COL1               COL1               COL1               COL1
----               ----               ----               ----
1                   1                   1                  1
2                   2                   NULL               2
3                   3                   3                  5
4                   NULL                5                  6

<SQL>
SELECT COUNT(*) FROM 
   SQLD_34_26_01 T1,
   SQLD_34_26_02 T2,
   SQLD_34_26_03 T3,
   SQLD_34_26_04 T4
WHERE T1.COL1 = T2.COL1(+)
      AND T2.COL1 = T3.COL1(+)
      AND T3.COL1 = T4.COL1;
📝Memo 



1) 12) 23) 34) 4



 


300x250






문제 27. 아래 테이블에 대해 수행된 SQL결과와 보기의 SQL의 결과가 같은 것으로 올바른 것은? 정답확인🌼
<SQLD_34_27>
<SQL>
SELECT DEPT_ID, SALARY
FROM ( SELECT ROW_NUMBER()
         OVER(PARTITION BY DEPT_ID
         ORDER BY SALARY DESC) RN,
       DEPT_ID, SALARY
       FROM SQLD_34_27
     )
WHERE RN = 1;
📝Memo 






1)SELECT DEPT_ID, SALARY FROM (SELECT RANK() OVER(PARTITION BY DEPT_ID ORDER BY SALARY DESC) RN , DEPT_ID, SALARYFROM SQLD_34_27 ) WHERE RN = 1








2)SELECT DEPT_ID, MAX(SALARY) AS SALARY FROM SQLD_34_27GROUP BY DEPT_ID








3)SELECT DEPT_ID, SALARYFROM SQLD_34_27WHERE ROWNUM =1ORDER BY DEPT_ID, SALARY DESC ;








4)SELECT DEPT_ID, SALARYFROM SQLD_34_27WHERE SALARY = (SELECT MAX(SALARY) FROM SQLD_34_27 )






 

문제 28. 순번을 구하는 그룹함수가 아닌 것은? 정답확인🌼



1) RANK2) ROW_NUMBER3) DENSE_RANK4) RATIO_TO_REPORT



 

문제 29. 아래의 SCRIPT 에서 최종결과로 알맞은 것은?  정답확인🌼
<SCRIPT>
CREATE TABLE SQLD_34_29 (N1 NUMBER, N2 NUMBER) ;
-------------------------------------------------------------------------- 
INSERT INTO SQLD_34_29 VALUES (1,1);
INSERT INTO SQLD_34_29 VALUES (2,2);
SAVEPOINT SV1;

UPDATE SQLD_34_29 SET N1=4 WHERE N2=1; 
SAVEPOINT SV1;

DELETE SQLD_34_29 WHERE N1 >= 2; 
ROLLBACK TO SAVEPOINT SV1;

SELECT MAX(N1) FROM SQLD_34_29;
📝Memo 



1) NULL2) 43) 24) 답 없음



 

문제 30. 아래의 SQL을 ORACLE 과 SQL SERVER에서 수행할 때 SQL에 대해 틀린 설명은? (AUTO COMMIT은 FALSE로 설정) 정답확인🌼
<SCRIPT>
UPDATE SQLD_34_30 SET N1=3 WHERE N2=1; 
CREATE TABLE SQLD_34_30_TEMP (N1 NUMBER); 
ROLLBACK;






1) SQL SERVER 의 경우 ROLLBACK 이 된 후 UPDATE 와 CREATE 구문 모두 취소된다 2) SQL SERVER 의 경우 ROLLBACK 이 된 후 SQLD_34_21_TEMP 는 만들어지지 않는다. 3) ORACLE 의 경우 ROLLBACK 이 된 후 UPDATE 와 CREATE 구문 모두 취소된다.4) ORACLE 의 경우 UPDATE 는 취소되지 않는다.






 

문제 31. 아래의 ERD 를 참고하여 보기의 SQL중 결과가 다른 하나는? 정답확인🌼

<SQL>
SELECT 고객ID, 이용일자 
FROM SQLD_34_31_01 
UNION
SELECT 고객ID, 이용일자 
FROM SQLD_34_31_02
📝Memo 

문제 32. 아래와 같은 데이터를 가진 테이블이 있을 때 중복되는 이름 중 아이디가 제일 작은것만 남도록 하는 SQL을 완성하시오정답확인🌼
<SQLD_34_32>
<SQL>
DELETE SQLD_34_32
WHERE ID NOT IN (           )

<RESULT>
    ID      NAME
   --------------
    1         A
    1         C
    1         D
📝Memo 






1) SELECT MAX(ID) FROM SQLD_34_32 GROUP BY NAME 2) SELECT MIN(ID) FROM SQLD_34_32 GROUP BY NAME 3) SELECT MAX(ID) FROM SQLD_34_32 GROUP BY ID4) SELECT MIN(ID) FROM SQLD_34_32 GROUP BY ID






 

문제 33. 아래의 SQL 에 대한 설명 중 올바른 것은? 정답확인🌼
<SQL>
SELECT*
FROM SQLD_34_33
WHERE EMP_NAME LIKE 'A%'
📝Memo 



1) 테이블의 EMP_NAME 이 A 또는 a 로 시작하는 모든 row2) 테이블의 EMP_NAME 이 A 로 시작하는 모든 row3) 테이블의 EMP_NAME 이 A 로 끝나는 모든 row4) 테이블의 EMP_NAME 이 A 또는 a 로 끝나는 모든 row



 

문제 34. 다음 보기 중 물리적 테이블명으로 가장 적절한 것은?  정답확인🌼



1) TAB_1002) 100_TAB3) TAB-1004) 100-TAB



 

문제 35. 다음 보기 중 반올림 함수로 알맞은 것은? 정답확인🌼



1) ROUND2) CEIL3) TRUNC4) ABS



 

문제 36. 아래의 SQL문을 수행한 결과로 잘못된 것은?  정답확인🌼
CREATE TABLE 주문 (
    C1 NUMBER(10),
    C2 DATE,
    C3 VARCHAR(10),
    C4 NUMBER DEFAULT 100
);

INSERT INTO 주문 (C1,C2,C3) VALUES (1, SYSDATE, 'TEST1');



1) INSERT INTO 주문 VALUES(2, SYSDATE, 'TEST2'); 2) DELETE 주문3) DELETE FROM 주문;4) UPDATE 주문 SET C1=1;



 

문제 37. ORDER BY 의 특징으로 가장 적절하지 않은 것은? 정답확인🌼



1) ORDER BY 의 기본 정렬은 내림차순이다2) SELECT 구문에 사용되지 않은 컬럼도 OERDER BY 구문에서 사용할 수 있다3) ORDER BY 1, COL1 과 같이 숫자와 컬럼을 혼용하여 사용할 수 있다4) ORACLE 은 NULL 을 가장 큰 값으로 취급하여 ORDER BY 시 맨 뒤로 정렬되고 SQL SERVER 반대로 가장 앞으로 정렬한다.



 

문제 38. 아래의 테이블에 대해서 다음의 SQL을 수행한 결과로 알맞은 것은 정답확인🌼

📝Memo 
<SQL>
SELECT A.회원번호, B.등급
FROM (SELECT 회원번호, SUM(AMT)
   FROM SQLD_34_38_01
   GROUP BY 회원번호) A , SQLD_34_38_02 B 
WHERE 1=1
AND A.AMT BETWEEN B.MIN_AMT AND B.MAX_AMT

 

문제 39. 조인 기법 설명중 가장 적절한 것은? 정답확인🌼




1) Hash Join 은 정렬 작업이 없어 정렬이 부담되는 대량배치작업에 유리하다.2) 대용량의 데이터를 가진 두개 테이블을 조인할 때 Hash Join 보다 Nested Loop Join 이 더 유리하다 3) 옵티마이저는 조인컬럼에 인덱스가 존재하지 않으면 Nested Loop Join 을 선호한다.4) Nested Loop Join 기법은 배치작업에서 선호하는 조인기법이다.




 

문제 40. 주어진 테이블에서 아래의 SQL문을 수행하였을 때 사원과 관리자, 그리고 최상위 관리자를 반환하도록 작성된 SQL을 완성하시오. 정답확인🌼
<SQL >
SELECT A.EMPLOYEE_ID,
    A.MANAGER_ID AS A_MANAGER_ID, 
    B.EMPLOYEE_ID AS B_EMPLOYEE_ID, 
    B.MANAGER_ID AS B_MANAGER_ID, 
    A.LAST_NAME
FROM HR.EMPLOYEES A
       ( ) HR.EMPLOYEES B ON ( )
WHERE 1=1
AND A.EMPLOYEE_ID < 200 
ORDER BY EMPLOYEE_ID ;
📝Memo 






1) INNER JOIN , A.MANAGER_ID = B.EMPLOYEE_ID2) INNER JOIN , A.EMPLOYEE_ID = B.MAANGER_ID3) LEFT OUTER JOIN , A.MANAGER_ID = B.EMPLOYEE_ID 4) LEFT OUTER JOIN , A.EMPLOYEE_ID = B.MAANGER_ID






 

문제 41. SQL 집합 연산자 INTERSECT 에 대한 설명 중 올바른 것은? 정답확인🌼






1) 결과의 합집합으로 중복된 행을 모두 포함한다.2) 결과의 합집합으로 중복된 행은 하나의 행으로 표시한다 3) 결과의 교집합으로 중복된 행을 하나의 행으로 표시한다4) 결과의 교집합으로 중복된 행을 모두 포함한다






 

문제 42. 다음중 Window function 에 대한 설명중 적절한 것은? 정답확인🌼






1) Partition 과 Group By 구문은 의미적으로 완전히 다르다2) Sum,max, min 등과 같은 집계 window function을 사용할 때 window 절과 함께 사용하면 집계의 대상이 되는 레코드 범위를 지정할 수 있다 3) Window function 처리로 인해 결과 건수가 줄어들 수 있다4) GROUP BY 구문과 Window function 은 병행하여 사용 할 수 있다






- - - - - - - - 주관식 - - - - - - - - 

문제 43. 부서에 대한 정보를 보여주고자 한다. 부서명, 부서에 소속된 사원명, 부서번호를 보여주고자 하며, 사원이 없는 부서도 보여주고자 할 때 아래의 SQL을 완성하시오.정답확인🌼
<SQL>
SELECT A.DEPT_NM, B.EMP_NM, A.DEPT_ID
FROM DEPT A ( ) EMP B ON (A.DEPT_ID = B.DEPT_ID )
✏️
 

문제 44. 아래와 같은 테이블이 있을 때 아래의 SQL을 수행했을 때 두번째로 나오는 값을 작성하시오.정답확인🌼

<SQL>
SELECT CODE
FROM SQLD_34_44
START WITH SUPER_ID IS NULL 
CONNECT BY PRIOR ID = SUPER_ID 
ORDER SIBLINGS BY CODE DESC;
✏️
 

문제 45. 아래와 같은 테이블이 있을 때 연봉이 2번째, 3번째로 높은 사원의 정보를 구하고 한다. 아래의 SQL을 완성하시오.

<SQL> SELECT * 
FROM (
   SELECT EMPLOYEE_ID, LAST_NAME, SALARY, RANK() OVER(ORDER BY SALARY DESC ) RN 
   FROM SQLD_34_45
   WHERE 1=1
   AND SALARY < (SELECT ( ) (SALARY) FROM EMPLOYEES ) )
WHERE RN < 3;
✏️정답확인🌼
 

문제 46. SELECT UPPER(sqldeveloper) FROM DUAL 의 결과를 적으시오.
✏️정답확인🌼
 

문제 47. 아래와 같은 데이터를 가진 테이블이 있을 때 SQL의 수행 결과를 적으시오. 정답확인🌼
<SQLD_34_47>
<SQL>
WITH WITH_TAB (last_name, EMP_ID, MGR_ID, sum_salary ) 
AS (
   SELECT last_name,EMPLOYEE_ID,MANAGER_ID, salary 
   FROM HR.EMPLOYEES
   WHERE MANAGER_ID IS NULL
UNION ALL
   SELECT a.last_name, a.EMPLoYEE_ID, a.MANAGER_ID, a.salary + b.sum_salary 
   FROM HR.EMPLOYEES A, WITH_TAB B
   WHERE B.EMP_ID = A.MANAGER_ID 
   )
SELECT SUM_SALARY FROM WITH_TAB 
WHERE EMP_ID = 105;
✏️
 

문제 48. 아래와 같은 데이터를 가진 테이블이 있을 때 SQL의 결과를 작성하시오.
<SQLD_34_48>
<SQL>
SELECT COUNT(*)
FROM SQLD_34_48 
WHERE SALARY > 200
   OR MGR_ID IS NULL 
 AND CODE ='B'
✏️정답확인🌼
 

문제 49. 아래와 같은 데이터를 가진 테이블에 대한 SQL을 수행했을 때 결과가 다음과 같다. SQL을 완성하시오.

<SQL>
SELECT VAL, COUNT(*) AS CNT
  FROM (
       SELECT ( )(4) OVER (ORDER BY COL1) AS VAL 
       FROM SQLD_34_X7
       ) 
WHERE 1=1
GROUP BY VAL 
ORDER BY 1;
✏️정답확인🌼
 

문제 50. 아래의 SQL 결과를 출력하는 SQL을 완성하시오.

SELECT EMPLOYEE_ID, 
     DEPARTMENT_ID, 
     LAST_NAME, 
     SALARY,
     LAG(SALARY, (   )) OVER(PARTITION BY DEPARTMENT_ID ORDER BY SALARY)
AS BEFORE_SALARY
FROM SQLD_50
WHERE EMPLOYEE_ID < 190;
✏️정답확인🌼


📝SQLD. 제 34 회 기출 문제(총 50) - 정답 / 해설
 

1. 정답 :  4
📖문제확인
 
해설 : 도메인의 특징 데이터 타입, 크기 지정
 

2. 정답 :  3
📖문제확인
 
해설 : 

주식별자 / 보조식별자 : 대표성 유무
- - - - - - - - - - - - - 
내부 식별자 : 스스로 생성
외부 식별자 : 받아옴
- - - - - - - - - - - - - 
단일 식별자 : 속성 1개
복합 식별자 : 속성 N개
- - - - - - - - - - - - - 
본질 식별자 : 업무에 의해 생성
인조 식별자 : 인위적으로
 

3. 정답 :  4
📖문제확인
 
해설 : 주식별자 특징 : 유최불존
유일성 : 유일하게 인스턴스 구분 가능
최소성 : 주식별자 속성 수 = 최소 
불변성 : 주식별자 값은 변경 X
존재성 : 반드시 값이 들어와야한다 (NOT NULL)
 

4. 정답 :  2
📖문제확인
 
해설 : 엔터티 (업무상 관리하려는 대상)
 

5. 정답 :  4
📖문제확인
 
해설 : 
 

6. 정답 :  4
📖문제확인
 
해설 : 반정규화 종류 (테이블, 속성, 관계)
 

7. 정답 :  4 
📖문제확인
 
해설 : 
 

8. 정답 :  3
📖문제확인
 
해설 : 여러제품(N)을 가질 수 있다.
출처 : https://ppomelo.tistory.com/51
 

9. 정답 :  2 
📖문제확인
 
해설 : 
 

10. 정답 :  2 
📖문제확인
 
해설 : 
1) 엔터티는 2개 이상의 속성으로 구성
2) 엔터티를 설명하고, 인스턴스의 구성요소이다. O
3) 하나의 속성은 하나의 값을 갖는다.
4) 속성의 특성 : 기본 속성 (모든 일반적 속성)
                         설계 속성 (새로 만든다.)
                         파생 속성 (영향을받아 발생, 빠른 성능, 계산)
 

11. 정답 :  2
📖문제확인
 
해설 : 
DROP : 구조까지 모두 삭제
TRUNCATE : 구조 유지 (데이터만 삭제)
DELETE : 원하는 데이터만 삭제, 복구 가능, 용량이 줄지않고 느림
 

12. 정답 :  4
📖문제확인
 
해설 : ORA-01785 에러 : SELECT 절에 없는 컬럼의 자리수를 사용할 수 없음
 

13. 정답 :  1 
📖문제확인
 
해설 : 



Procedure
Trigger


EXECUTE 명령어로 실행
자동 실행 (이벤트 발생시)


CREATE Procedure
CREATE Trigger


COMMIT, ROLLBACK 가능
COMMIT, ROLLBACK 불가능



 

14. 정답 :  3
📖문제확인
 
해설 : PRIOR 자식 = 부모 면 순방향임 MANAGER 가 부모, EMPLOYEE 가 자식
 

15. 정답 :  3
📖문제확인
 
해설 : 선수명 ASC(오름차순),팀명(default 오름차순), 3 DESC(3번째 열 내림차순)
 

16. 정답 :  1 
📖문제확인
 
해설 : WHERE 절에 별도의 조건절이 없을 경우 NESTED LOOP JOIN 이 반드시 좋다고 할 수 없음



NL Join
Sort Merge Join
Hash Join


랜덤 액세스
등가, 비등가 조인 가능
등가조인만 가능


대용량 sort 작업 유리
조인키 기준 정렬
대량 작업 유리, 함수처리



 

17. 정답 :  3
📖문제확인
 
해설 : (a + b + c + d) 의 경우는 해당 로우에 대해서 계산이 되고 난 컬럼에 대해서 Sum 이 수행됨, (a) + (b) .. 의 경우 각각의 sum 을 수행하고 나서 다시 사칙연산이 수행됨

18. 정답 :  2 
📖문제확인
 
해설 : 1) 2 , 3) 10 , 4) A
 

19. 정답 :  3
📖문제확인
 
해설 : B A 2 1 / 나머지 : D B 4 2 
 

20. 정답 :  2
📖문제확인
 
해설 : 롤업은 인수 순서가 중요(ID 총합과 전체 총합 출력), CUBE는 ID총합,DPET_NM 총합, 전체총합 , GroupingSets는 총합 X
 

21. 정답 :  1 
📖문제확인
 
해설 : ID,DEPT_NM 각각 총합, 전체 총합 출력
CUBE(ID,DEPT_NM)
 

22. 정답 :  1 
📖문제확인
 
해설 : 
ROLLUP : 인수 순서중요(계층적), Order by 로 정렬
CUBE : 모든값에 다차원집계 생성 / 시스템에 많은 부하
GroupingSets : 인수 순서무관 (평등)
 

23. 정답 :  1
 
📖문제확인
해설 : 없음 NULL (공집합) 공집합과 0은 다르다.
 

24. 정답 :  3
📖문제확인
 
해설 : 트랜잭션 특성
1. 원자성 : 트랜잭션에서 연산들이 모두 성공하거나 모두 실패 해야함. (계좌이체)
2. 일관성 : 트랜잭션 실행 전 DB 내용이 잘못 되지 않으면 실행 후도 잘못 되지 않아야 함
3. 고립성 : 트랜잭션 실행 도중 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안된다.
4. 지속성 : 트랜잭션이 성공적으로 수행되면 DB의 내용은 영구적으로 저장된다.
 

25. 정답 :  4
📖문제확인
 
해설 : UNION ALL (합집합) 
 

26. 정답 :  1
📖문제확인
 
해설 : 
 

27. 정답 :  2
📖문제확인
 
해설 : 
RANK() : 중복값은 중복등수, 등수 건너뜀(1위, 1위, 3위, 4위)
DENSE_RANK() : 중복값은 중복등수, 등수 안 건너뜀(1위, 1위, 2위, 2위)
ROW_NUMBER() : 중복값이 있어도 고유 등수 부여(1위, 2위, 3위, 4위)
- - - - - - - - - - - - - -
PARTITION BY DEPT_ID / ORDER BY SALARY DESC
-- DEPT_ID 로 그룹묶고, SALARY 많은 순으로 정렬
WHERE RN = 1
-- 각그룹(DEPT_ID)에 월급 많은 1등 출력
 

28. 정답 :  4
📖문제확인
 
해설 : RATIO_TO_REPORT (전체 SUM값에 대한 행별 칼럼값, 0~1 사이값)
 

29. 정답 :  2
📖문제확인
 
해설 : 같은 이름의 SAVEPOINT가 저장될 경우 나중에 저장된 SAVEPOINT 로 ROLLBACK(복원) 함.
 

30. 정답 :  3
📖문제확인
 
해설 : oracle 의 경우 기본 값이 auto commit off 로 ddl 이 일어날 경우 묵시적 commit 이 됨 (설정 불가), sql server 의 경우 기본 값이 auto commit on 으로 false 가 될 경우 ddl 도 묵시적 commit 이 되지 않음
1) SQL 서버의 경우, AUTO COMMIT 꺼두면 UPDATE, CREATE 모두 취소되고 다시 테이블이 생성되지 않음
2) 오라클은 DDL의 AUTO COMMIT이 기본이기 때문에 CREATE 취소되지 않고, UPDATE도 취소 X
 

31. 정답 :  1
📖문제확인
 
해설 : UNION(합집합, 중복허용 X) / A, B 고객 ID, 이용일자 중복없이 모두 선택해서 CROSS JOIN
 

32. 정답 :  2
📖문제확인
 
해설 : 
 

33. 정답 :  2
📖문제확인
 
해설 : _ (한글자), A%(A로 시작하는), %A(A로 끝나는)
 

34. 정답 :  1
📖문제확인
 
해설 : 
 

35. 정답 :  1 
📖문제확인
 
해설 : ROUND (반올림), CEIL (올림)
 

36. 정답 :  1
📖문제확인
 
해설 : ORA-00947 에러
 

37. 정답 :  1
📖문제확인
 
해설 : ORDER BY default 오름차순
 

38. 정답 :  1
📖문제확인
 
해설 : 순서 ( FROM - WHERE - GROUP BY - HAVING - SELECT - ORDER BY )
FROM 절 회원번호로 그룹 묶고, 회원번호와 그룹 AMT 합을 A , 2번째 표 전체 선택 회원번호랑 등급 SELECT
AND 절 : B의 MIN_AMT ≤ A의 AMT 합 ≤ B의 MAX_AMT
 

39. 정답 :  1
📖문제확인
 
해설 : 
 

40. 정답 :  3
📖문제확인
 
해설 : 최상위 관리자가 나올려면 left outer join 이 되어야 함. 최상위 관리자는 manager_id 가 null 이거나 없기 때문.
 

41. 정답 :  3
📖문제확인
 
해설 : 
합집합 : UNION (느림)
중복허용 합집합 : UNION ALL (빠름)
차집합 : MINUS(오라클), EXCEPT(SQL 서버)
교집합 : INTERSECT
 

42. 정답 :  2
📖문제확인
 
해설 : 
1) Partition by 와 Group by 는 파티션 분할한다는 점에서 유사
2) 집계 Window Function(sum, max, min)을 Window절과 함께 사용하면 레코드 범위(집계대상) 지정가능
3) Window Function 으로 결과 건수 줄지 않음
4) group by, Window Function 병행 불가
 
 - - - - - - - - 주관식 - - - - - - - - 
 

43. 정답 :  LEFT OUTER JOIN
📖문제확인
 
해설 : 사원 없는 부서도 출력 
 

44. 정답 :  C
📖문제확인
 
해설 : 
Start with SUPER_ID IS NULL
->(1, NULL, A) 선택(루트 LEVEL1)
CONNECT BY PRIOR ID = SUPER_ID 
-> ID가 자식 SUPER_ID 가 부모 / ID=2,3은 SUPER_ID=1 의 자식 / ID=4는 SUPER_ID=2의 자식
ORDER SIBLINGS BY 는 같은 레벨 내에서 정렬
-> ID=2,3은 둘다 LEVEL=1 이므로 정렬, CODE DESC 코드 뒷순서 부터 정렬
2번째 값 C 
CODE
----------
A
C
B
D
 

45. 정답 :  MAX
📖문제확인
 
해설 : SALARY < (SELECT (MAX)(SALARY) FROM EMPLOYEES))
-> 최댓값보다 작은 월급
 

46. 정답 :  SQLDEVELOPER
📖문제확인
 
해설 : UPPER ( 대문자로 변환 ), LOWER ( 소문자로 변환 ), INITCAP ( 첫 번째 문자만 대문자로 변환 )
 

47. 정답 :  54800
📖문제확인
 
해설 : a.salary + b.sum_salary (현재 노드에서 루트 노드까지의 salary 합)
emp_id 가 105
(with 절안에 B.EMP_ID = A.MANAGER_ID 조건 이 있으므로)
105의 매니저는 103
103의 매니저는 102
102의 매니저는 100
따라서 105의 sum_salary 는 103, 102, 100을 포함해야 한다.
4600 + 9000 + 17000 + 24000 = 54800
 

48. 정답 :  3
📖문제확인
 
해설 : NOT - AND - OR 순으로 연산
 

49. 정답 :  NTILE
📖문제확인
 
해설 : NTILE (전체 건수를 인수값으로 N등분함)
 

50. 정답 :  2
📖문제확인
 
해설 : LAG는 이전 N번째 행을 가져옴 (해당 쿼리를 보면 두번째 이전의 salary 값을 가져오므로 답은 2 가 된다.)
DEPARTMENT_ID 그룹, SALARY 오름차순 정렬
 

 
sqld 34회 기출문제복원 / 정답 출처 : 데이터 전문가 포럼  